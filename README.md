# Maps

In main deschidem fisierul de output si verificam care dintre cerinte trebuie sa o rezolvam. Pentru cerinta 1 ne construim arborele neorientat ii aflam numarul de componente conexe si afisarea in ordine crescatoare a drumurilor minime, iar pentru cerinta 2 deschidem fisierul de intrare, construim arborele orientat, luam din fisier si valorile nodurilor, dupa care apelam functia task2 care rezolva toata cerinta. La final eliberam memoria.

In fisierul cu functii avem definite functiile de alocare a unui grafic, care aloca spatiu pentru structura graficului, pentru cele nr noduri (un vector de stringuri si o lista de adiacenta)
- functia de distrugere doreste eliberarea memoriei pentru structura graficului
- CitGrafNeorientat -- construirea graficului neorientat luand date din fisier; primele 2 valori sunt numariul de noduri si numarul de muchii; alocam spatiu pentru un graf cu n noduri; incepem sa luam din fisier cele m muchii si sa punem in graf valorile pe pozitiile corespunzatoare; cautam in graf daca nodul sursa a fost deja citit (ok = 1), iar daca nu a fost citit (ok = 2) il punem pe pozitia i in vectorul de stringuri; alocam spatiu pentru o noua celula in lista de adiacenta pe care o legam la ultima celula din lista sau la p daca ant nu exista si ii punem valorile corespunzatoare in ea; la fel se procedeaza si pentru drumul invers doar ca acum d este sursa si s destinatia
- CitGrafOrientat -- construirea graficului orientat; este identic cu citirea grafucului neorientat doar ca nu mai exista si drumul invers, aici muchiile devenind arce
- CitNoduri -- alocam spatiu pentru un vector in care pe fiecare pozitie o sa fie valoarea nodului din vectorul de stringuri; citim cele n valori si le punem pe pozitiile corespunzatoare; greutatea o punem pe pozitia 0 pentru ca aceasta pozitie este nefolositoare
- dfs -- parcurgerea arborelui si marcarea in vectorul de vizitat; parcurgere recursiva; cautatm indexul nodului primit ca parametru, in visited punem valoarea ic, apoi pargurgem graful; cand mai dam de un nou nod care nu este vizitat dar este in lista de adiacenta a vechiului nod , il marcam ca vizitat
- nr_comp_conexe -- functia returneaza ic (valoare numarului de componente); apelam dfs pentru primul nod, apoi parcurgen vectorul de vizitat si cand gasim un nod prin care nu am trecut plusam ic si apelan dfs pentru nodul respectiv
- mindistance / minscor -- returneaza nodul cu cea mai mica valoare in vectorul de distante; diferenta dintre ele este este tipul de date retinut in vectorul de distante
- Dijkstra -- cautam indexul nodului primit ca parametru, actualizam valorile din cei 3 vectori de pe pozitia indexului si incepem parcurgerea grafului; cautam scorul minim, il marcam ca vizitat, apoi parcurgem lista lui de adiacenta si pentru fiecare nod calculam scorul si actualizam informatiile din cei 3 vetori daca nu am mai trecut prin nod si valoarea actuala este mai mare decat cea calculata acum la care am adunat scorul nodului din care am plecat
- afisare_noduri -- functie apelata recursiv care afiseaza nodurile prin care trecem de la insula la corabie
- taks2 -- aflam indexurile pe care sunt stringurile "Insula" si "Corabie"; alocam memorie pentru cei 4 vectori; daca valoarea variabilei corabie ramane egala cu -1 atunci inseamna ca nu exista drum de la corabie la insula, altfel aplicam algoritmul Dijkstra pentru nodul "Insula"; daca in vectorul de vizitat ramene valoarea 0 pe pozitia variabilei corabie atunci inseamna ca nu exista drum de la insula la corabie; pentru ultimul caz atribuimvariabilei min valoarea nodului cel are ca parinte pe nodul "Insula", apelam functia ce afiseaza nodurile, aflam valoarea minima a nodurilor prin care trecem si afisam si celelalte 3 informatii(distanta care este distances[corabie], vgreutatea maxima a comorii care este min si numarul de drumuri pentru a transporta toata comoara = nr_drumuri)
- prim -- drumul minim pentru fiecare componenta conexa; cautam indexul nodului primit ca parametru; parcurgem arborele, aflam distanta minima, marcam nodul cu distanta minima ca vizitat, apoi parcurgem lista lui de adiacenta si actualizam informatiile din cei 2 vector daca nodul in care mergem nu este vizitat si costuyl drumului e mai mic decat valoarea actuala din vectorul de distante; dupa parcurgem vectorul de parinti si aflam suma minima adunand distantele
- cmpm -- o functie de compararea care ne ajuta la qsort
- drum_min -- apelam functia prim pentru primul nod, punem valoarea returnata in vectorul drm_min; verificam daca toate nodurile sunt vizitate si in cav contrat apelam din nou functia prim si punem valoarea pe urmatoarea pozitie in vectorum drum_min; sortam vectorul drum_min si il afisam.
